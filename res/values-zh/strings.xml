<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="designpattern_factorymethod_activity_des">
        \t工厂方法：用于生产一系列产品,主要有4个角色 - 1、抽象工厂 2、具体工厂 3、抽象产品 4、具体产品。 \n
        \t侧重点在产品，没看到只要一个工厂就可以搞定吗!\n\n
        \t这里有个特例：简单工厂 - 没有抽象工厂角色，只有一个具体工厂。\n\n
        \t客户端免除了直接创建产品对象的责任，而仅仅负责“消费”产品.
    </string>
    <string name="designpattern_abstractfactory_activity_des">
        \t抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。\n
        \t如果抽象产品存在不同的实现的时候，可以考虑用抽象工厂。\n
        \t和工厂方法相比，引入了一个产品族概念，抽象工厂不仅仅只是一个创建系列产品，而是可以创建产品族的每一个产品，比如车分：Benz（奔驰）、Bmw（宝马）、Audi（奥迪），如果只是这样按类别分系列，用工厂方法就可以，如果还分跑车和普通车等而且夸系列就可以考虑用抽象工厂\n
        \t适用场景：\n
        \t\t1.在编码时不能预见需要创建哪种类的实例。
        \t\t2.系统不应依赖于产品类实例如何被创建、组合和表达的细节\n
    </string>
    <string name="designpattern_sington_activity_des">
        \t单例模式的优点：在内存中只有一个对象，节省内存空间；避免频繁的创建销毁对象，可以提高性能；避免对共享资源的多重占用；可以全局访问。\n\n
        \t适用场景：\n
        \t\t需要频繁实例化然后销毁的对象。\n
        \t\t创建对象时耗时过多或者耗资源过多，但又经常用到的对象。\n
        \t\t有状态的工具类对象。\n
        \t\t频繁访问数据库或文件的对象。\n
        \t\t以及其他所有要求只有一个对象的场景。\n\n
        \t单例模式注意事项：\n
        \t\t只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。\n
        \t\t不要做断开单例类对象与类中静态引用的危险操作。\n
        \t\t多线程使用单例使用共享资源时，注意线程安全问题。
    </string>
    <string name="designpattern_builder_activity_des">
        \t将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n
        \t使用场景：\n
        \t\t相同的方法，不同的执行顺序，产生不同的事件结果时。；\n
        \t\t多个部件或零件，都可以装配到一个对象中，当是产品的运行结果又不相同时。；\n
        \t\t产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这时候使用创建者模式非常适合。；\n
        \t\t当初始化一个对象特别复杂，如参数多，而且很多参数都是默认值时。\n\n
        \t建造者模式的优点\n
        \t\t首先，建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。\n
        \t\t其次，建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。\n\n
        \t建造者模式与工厂模式相比：建造者模式仅仅只比工厂模式多了一个“导演类”的角色；建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。一般来说，如果产品的建造很复杂，那么请用工厂模式；如果产品的建造更复杂，那么请用建造者模式。
    </string>
    <string name="designpattern_prototype_activity_des">
        \t原型模式主要用于对象的复制，它的核心是就是类图中的原型类Prototype。Prototype类需要具备以下两个条件：\n
        \t\t实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。
        \t\t重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需要将clone方法的作用域修改为public类型。\n\n
        \t原型模式优点：\n
        \t\t创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。\n
        \t\t另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。\n\n
        \t适用场景:因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。\n\n
        \t原型模式的注意事项:\n
        \t\t1、使用原型模式复制对象不会调用类的构造方法，甚至连访问权限都对原型模式无效。【单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。】\n
        \t\t2、深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。
    </string>
    <string name="designpattern_templatemethod_activity_des">
        \t模版方法模式由一个抽象类和一个（或一组）实现类通过继承结构组成，抽象类中的方法分为三种：\n
        \t\t抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。\n
        \t\t模版方法：由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。\n
        \t\t钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。\n
        \t抽象类的任务是搭建逻辑的框架，通常由经验丰富的人员编写，因为抽象类的好坏直接决定了程序是否稳定性。\n\n
        \t模版方法的优点及适用场景\n
        \t\t容易扩展。一般来说，抽象类中的模版方法是不易反生改变的部分，而抽象方法是容易反生变化的部分，因此通过增加实现类一般可以很容易实现功能的扩展，符合开闭原则。\n
        \t\t便于维护。对于模版方法模式来说，正是由于他们的主要逻辑相同，才使用了模版方法，假如不使用模版方法，任由这些相同的代码散乱的分布在不同的类中，维护起来是非常不方便的。\n
        \t\t比较灵活。因为有钩子方法，因此，子类的实现也可以影响父类中主逻辑的运行。但是，在灵活的同时，由于子类影响到了父类，违反了里氏替换原则，也会给程序带来风险。这就对抽象类的设计有了更高的要求。\n\n
        \t适用场景：在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模版方法模式。在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式。\n
    </string>
    <string name="designpattern_Mediator_activity_des">
        \t中介者模式又称为调停者模式，分为3部分：\n
        \t\t抽象中介者：定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。一般包括一个或几个抽象的事件方法，并由子类去实现。\n
        \t\t中介者实现类：从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响其他同时类。\n
        \t\t同事类：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。在类图中，同事类只有一个，这其实是现实的省略，在实际应用中，同事类一般由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。并且，同事类也可以表现为继承了同一个抽象类的一组实现组成。在中介者模式中，同事类之间必须通过中介者才能进行消息传递。\n\n
        \t中介者模式的优点
        \t\t适当地使用中介者模式可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。\n
        \t\t使用中介者模式可以将对象间一对多的关联转变为一对一的关联，使对象间的关系易于理解和维护。\n
        \t\t使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。\n
        \t适用场景\n
        \t\t类之间的关系是比较复杂的，比如：多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。如果引入中介者模式，那么同事类之间的关系将变为星型结构，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。\n
        \t\t类A类B互相影响，就称为同事类，对于那种同事类之间是网状结构的关系，才会考虑使用中介者模式。
    </string>
    <string name="designpattern_Observer_Activity_des">
        \t观察者模式中，包括四个角色：\n
        \t\t被观察者：从类图中可以看到，类中有一个用来存放观察者对象的Vector容器（之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的），这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。\n
        \t\t观察者：观察者角色一般是一个接口，它只有一个update方法，在被观察者状态发生变化时，这个方法就会被触发调用。\n
        \t\t具体的被观察者：使用这个角色是为了便于扩展，可以在此角色中定义具体的业务逻辑。\n
        \t\t具体的观察者：观察者接口的具体实现，在这个角色中，将定义被观察者对象状态发生变化时所要处理的逻辑。\n\n
        \t观察者模式的优点:\n
        \t\t观察者与被观察者之间是属于轻度的关联关系，并且是抽象耦合的，这样，对于两者来说都比较容易进行扩展。\n
        \t\t观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察者的方法进行处理。但同时，这也算是观察者模式一个缺点，由于是链式触发，当观察者比较多的时候，性能问题是比较令人担忧的。并且，在链式结构中，比较容易出现循环引用的错误，造成系统假死。
    </string>
    <string name="designpattern_Visitor_Activity_des">
        \t在访问者模式中，主要包括下面几个角色：\n
        \t\t抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。\n
        \t\t访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。\n
        \t\t抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。\n
        \t\t元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。\n
        \t\t结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。\n\n
        \t访问者模式的优点:\n
        \t\t符合单一职责原则：凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。\n
        \t\t扩展性良好：元素类可以通过接受不同的访问者来实现对不同操作的扩展。\n
        \t访问者模式的缺陷：增加新的元素类比较困难。在访问者类中，每一个元素类都有它对应的处理方法，也就是说，每增加一个元素类都需要修改访问者类（也包括访问者类的子类或者实现类），修改起来相当麻烦。也就是说，在元素类数目不确定的情况下，应该慎用访问者模式。所以，访问者模式比较适用于对已有功能的重构，比如说，一个项目的基本功能已经确定下来，元素类的数据已经基本确定下来不会变了，会变的只是这些元素内的相关操作，这时候，我们可以使用访问者模式对原有的代码进行重构一遍，这样一来，就可以在不修改各个元素类的情况下，对原有功能进行修改。\n\n
        \t适用场景:\n
        \t\t假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。\n
        \t\t假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。
    </string>
    <string name="designpattern_Command_Activity_des">
        \t命令模式基本结构：\n
        \t\tCommand类：是一个抽象类，类中对需要执行的命令进行声明，一般来说要对外公布一个execute方法用来执行命令。\n
        \t\tConcreteCommand类：Command类的实现类，对抽象类中声明的方法进行实现。\n
        \t\tClient类：最终的客户端调用类。\n
        \t\tInvoker类：调用者，负责调用命令。\n
        \t\tReceiver类：接收者，负责接收命令并且执行命令。\n\n
        \t命令模式的优点:\n
        \t\t首先，命令模式的封装性很好：每个命令都被封装起来，对于客户端来说，需要什么功能就去调用相应的命令，而无需知道命令具体是怎么执行的。比如有一组文件操作的命令：新建文件、复制文件、删除文件。如果把这三个操作都封装成一个命令类，客户端只需要知道有这三个命令类即可，至于命令类中封装好的逻辑，客户端则无需知道。\n
        \t\t其次，命令模式的扩展性很好，在命令模式中，在接收者类中一般会对操作进行最基本的封装，命令类则通过对这些基本的操作进行二次封装，当增加新命令的时候，对命令类的编写一般不是从零开始的，有大量的接收者类可供调用，也有大量的命令类可供调用，代码的复用性很好。比如，文件的操作中，我们需要增加一个剪切文件的命令，则只需要把复制文件和删除文件这两个命令组合一下就行了，非常方便。\n\n
        \t命令模式的缺点:\n
        \t\t那就是命令如果很多，开发起来就要头疼了。特别是很多简单的命令，实现起来就几行代码的事，而使用命令模式的话，不用管命令多简单，都需要写一个命令类来封装。\n\n
        \t适用场景：对于大多数请求-响应模式的功能，比较适合使用命令模式，正如命令模式定义说的那样，命令模式对实现记录日志、撤销操作等功能比较方便。\n
    </string>
    <string name="designpattern_ChainofResponsibility_Activity_des">
        \t责任连模式的结构:\n
        \t\t责任连模式的类图非常简单，它由一个抽象地处理类和它的一组实现类组成：\n
        \t\t抽象处理类：抽象处理类中主要包含一个指向下一处理类的成员变量nextHandler和一个处理请求的方法handRequest，handRequest方法的主要主要思想是，如果满足处理的条件，则有本处理类来进行处理，否则由nextHandler来处理。\n
        \t\t具体处理类：具体处理类主要是对具体的处理逻辑和处理的适用条件进行实现。\n\n
        \t责任链模式的优缺点:\n
        \t\t责任链模式与if…else…相比，他的耦合性要低一些，因为它把条件判定都分散到了各个处理类中，并且这些处理类的优先处理顺序可以随意设定。\n
        \t\t责任链模式也有缺点，这与if…else…语句的缺点是一样的，那就是在找到正确的处理类之前，所有的判定条件都要被执行一遍，当责任链比较长时，性能问题比较严重。\n
        \t责任链模式的适用场景\n
        \t\t就像开始的例子那样，假如使用if…else…语句来组织一个责任链时感到力不从心，代码看上去很糟糕时，就可以使用责任链模式来进行重构。
    </string>
    <string name="designpattern_Strategy_Activity_des">
        \t策略模式的结构:\n
        \t\t封装类：也叫上下文，对策略进行二次封装，目的是避免高层模块对策略的直接调用。\n
        \t\t抽象策略：通常情况下为一个接口，当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码，此时，策略模式看上去更像是模版方法模式。\n
        \t\t具体策略：具体策略角色通常由一组封装了算法的类来担任，这些类之间可以根据需要自由替换。\n\n
        \t策略模式的主要优点有：\n
        \t\t策略类之间可以自由切换，由于策略类实现自同一个抽象，所以他们之间可以自由切换。\n
        \t\t易于扩展，增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展。\n
        \t\t避免使用多重条件，如果不使用策略模式，对于所有的算法，必须使用条件语句进行连接，通过条件判断来决定使用哪一种算法，在上一篇文章中我们已经提到，使用多重条件判断是非常不容易维护的。\n
        \t策略模式的缺点主要有两个：\n\n
        \t\t维护各个策略类会给开发带来额外开销，可能大家在这方面都有经验：一般来说，策略类的数量超过5个，就比较令人头疼了。\n
        \t\t必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的，因此，客户端应该知道有什么策略，并且了解各种策略之间的区别，否则，后果很严重。例如，有一个排序算法的策略模式，提供了快速排序、冒泡排序、选择排序这三种算法，客户端在使用这些算法之前，是不是先要明白这三种算法的适用情况？再比如，客户端要使用一个容器，有链表实现的，也有数组实现的，客户端是不是也要明白链表和数组有什么区别？就这一点来说是有悖于迪米特法则的。\n\n
        \t适用场景:\n
        \t\t几个类的主要逻辑相同，只在部分逻辑的算法和行为上稍有区别的情况。\n
        \t\t有几种相似的行为，或者说算法，客户端需要动态地决定使用哪一种，那么可以使用策略模式，将这些算法封装起来供客户端调用。\n\n
        \t策略模式是一种简单常用的模式，我们在进行开发的时候，会经常有意无意地使用它，一般来说，策略模式不会单独使用，跟模版方法模式、工厂模式等混合使用的情况比较多。。
    </string>
    <string name="designpattern_Iterator_Activity_des">
        \t迭代器模式的结构\n
        \t\t抽象容器：一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。\n
        \t\t具体容器：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。\n
        \t\t抽象迭代器：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法first()，取得下一个元素的方法next()，判断是否遍历结束的方法isDone()（或者叫hasNext()），移出当前对象的方法remove(),\n
        \t\t迭代器实现：实现迭代器接口中定义的方法，完成集合的迭代。\n\n
        \t迭代器模式的优点有：\n
        \t\t简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。\n
        \t\t可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。\n
        \t\t封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。\n\n
        \t迭代器模式的缺点：\n
        \t\t对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合。\n\n
        \t适用场景：\n
        \t\t迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器。系统实现容器的时候都给提供了迭代器，而且一般够用，除非自己新创建的集合。
    </string>
    <string name="designpattern_Interpreter_Activity_des">
        \t解释器模式的结构(这个模式用的比较少)\n
        \t\t抽象解释器：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器TerminalExpression和非终结符解释器NonterminalExpression完成。\n
        \t\t终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。\n
        \t\t非终结符表达式：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。\n
        \t\t环境角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。\n\n
        \t解释器模式的优缺点\n
        \t\t解释器是一个简单的语法分析工具，它最显著的优点就是扩展性，修改语法规则只需要修改相应的非终结符就可以了，若扩展语法，只需要增加非终结符类就可以了。\n
        \t\t但是，解释器模式会引起类的膨胀，每个语法都需要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来非常多的麻烦。同时，由于采用递归调用方法，每个非终结符表达式只关心与自己相关的表达式，每个表达式需要知道最终的结果，必须通过递归方式，无论是面向对象的语言还是面向过程的语言，递归都是一个不推荐的方式。由于使用了大量的循环和递归，效率是一个不容忽视的问题。特别是用于解释一个解析复杂、冗长的语法时，效率是难以忍受的。\n\n
        \t\适用场景：\n
        \t\t有一个简单的语法规则，比如一个sql语句，如果我们需要根据sql语句进行rm转换，就可以使用解释器模式来对语句进行解释。\n
        \t\t一些重复发生的问题，比如加减乘除四则运算，但是公式每次都不同，有时是a+b-c*d，有时是a*b+c-d，等等等等个，公式千变万化，但是都是由加减乘除四个非终结符来连接的，这时我们就可以使用解释器模式。
        \t\t解释器模式真的是一个比较少用的模式，因为对它的维护实在是太麻烦了，想象一下，一坨一坨的非终结符解释器，假如不是事先对文法的规则了如指掌，或者是文法特别简单，则很难读懂它的逻辑。解释器模式在实际的系统开发中使用的很少，因为他会引起效率、性能以及维护等问题。
    </string>
    <string name="designpattern_Memento_Activity_des">
        \t备忘录模式的结构\n
        \t\t发起人：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。\n
        \t\t备忘录：负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。\n
        \t\t管理角色：对备忘录进行管理，保存和提供备忘录。\n\n
        \t备忘录模式的优点有：\n
        \t\t当发起人角色中的状态改变时，有可能这是个错误的改变，我们使用备忘录模式就可以把这个错误的改变还原。\n
        \t\t备份的状态是保存在发起人角色之外的，这样，发起人角色就不需要对各个备份的状态进行管理。\n
        \t备忘录模式的缺点：\n
        \t\t在实际应用中，备忘录模式都是多状态和多备份的，发起人角色的状态需要存储到备忘录对象中，对资源的消耗是比较严重的。\n\n
        \t适用场景：\n
        \t\t如果有需要提供回滚操作的需求，使用备忘录模式非常适合，比如jdbc的事务操作，文本编辑器的Ctrl+Z恢复等。
    </string>
    <string name="designpattern_State_Activity_des">
        \t状态模式的结构\n
        \t\t抽象状态\n
        \t\t具体状态\n
        \t\t多状态的对象\n\n
        \t允许一个对象在其内部状态改变时改变它的行为. 这个对象看起来似乎修改了它的类.\n
        \t状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况.把状态的判断逻辑转移到表示不同状态的一系列类当中, 可以把复杂的判断逻辑简化.当一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为时, 就可以考虑使用状态模式了.\n
        \t适用场景:\n
        \t\t一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为.\n
        \t\t一个操作中含有庞大的多分支的条件语句, 且这些分支依赖于该对象的状态.\n
    </string>
    <string name="designpattern_Adapter_Activity_des">
        \t适配器模式的结构：\n
        \t\t目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。\n
        \t\t源(Adapee)角色：现在需要适配的接口。\n
        \t\t适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。\n\n
        \t类适配器和对象适配器的权衡\n
        \t\t类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。\n
        \t\t对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理  Adaptee的子类了。\n
        \t\t对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。\n
        \t\t对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。\n
        \t\t对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。\n
        \t\t对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。\n
        \t\t对于对象适配器，需要额外的引用来间接得到Adaptee。\n\n
        \t适配器模式的优点:\n
        \t\t适配器模式可以让两个没有任何关系得类在一起运行，只要适配器这个角色能够搞定他就成。\n
        \t\t增加了类的透明性。我们访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高层次模块时透明的，也是它不需要关心的。\n
        \t\t适配器模式可以让两个没有任何关系得类在一起运行，只要适配器这个角色能够搞定他就成。\n\t\t灵活性非常好\n
        \t适配器模式的缺点:\n
        \t\t过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。\n\n
        \t适用场景：\n
        \t\t你有动机修改了一个已经投产中的接口时，适配器模式可能是最适合你的模式。\n
        \t\t适配器模式最好在详细设计不要考虑它，它不是为了解决还处在开发阶段的问题，而是解决正在服役的项目问题。\n\n
        \t核心思想：对已经存在的源角色Adaptee按要求进行扩展接口，适配器通过继承Adaptee同时实现扩展接口，以达到【够在一起工作的】需要的需求。(一般在扩展接口的interface里面会把Adaptee里面需要用到的行为接口也加上。)
    </string>
    <string name="designpattern_Bridge_Activity_des">
        \t桥接模式主要应对的是：由于实际的需要，某个类具有两个或两个以上的维度变化，如果只是用继承将无法实现这种需要，或者使得设计变得相当臃肿。\n\n
        \t桥接模式的做法是把变化部分抽象出来，使变化部分与主类分离开来，从而将多个维度的变化彻底分离。最后，提供一个管理类来组合不同维度上的变化，通过这种组合来满足业务的需要。\n
        \t\t举个例子,对于笔记本的CPU评测,当安装Intel CPU的时候 评测分数比较高,而安装AMD CPU的时候，则评测分数相对低一些,这个是一唯影响,而配合上电脑品牌,就是二维影响\n\n
        \t桥接模式的角色:\n
        \t\t抽象对象角色AbstractComputer。对多维度的抽象的接口，通常在这个对象里面，要维护一个实现部分[ - 多维度]的对象引用,比如CpuAbility，在抽象对象里面的方法，需要调用实现部分的对象来完成。这个对象里面的方法，通常都是跟具体的业务相关的方法。\n
        \t\多个具体对象角色ConcreteComputer，通常在这些对象里面，定义跟实际业务相关的方法，这些方法的实现通常会使用Abstraction中定义的方法，也可能需要调用实现部分的对象来完成。\n
        \t\t变化维度抽象角色CpuAbility，这个接口不用和Abstraction里面的方法一致，通常是由Implementor接口提供基本的操作，而Abstraction里面定义的是基于这些基本操作的业务方法，也就是说Abstraction定义了基于这些基本操作的较高层次的操作。\n
        \t\t多个具体维度角色ConcreteCpu，实现当前维度的具体逻辑\n
    </string>
    <string name="designpattern_Composite_Activity_des">
        \t组合模式的定义：将具备相同行为和属性的对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n
        \t举例：硬盘、盒子、柜子都具有实价和折扣价属性，同时都有实销售价、折售价行为，我们就可以抽象一个Component类具备实价、折扣价和售价行为，同时增加(add)、删除(remove)、遍历组件内部对象的方法(可以是for也可以是Iterator)等对结构内部对象操作的行为，这样我们就可以【盒子.add(硬盘);柜子.add(盒子);】，然后我们就可以直接【柜子.netPrice()；】当然你可以得到三个物件的总实价也可以是三个物件的各自价格，这取决于你封装的行为。\n\n
        \t组合模式的角色：\n
        \t\t1.Component 是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。\n
        \t\t2.Leaf 在组合中表示叶子结点对象，叶子结点没有子结点。\n
        \t\t3.Composite 定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。\n\n
        \t适用场景：\n
        \t\t你想表示的对象具备树形结构，同时部分和整体具备相同的属性和行为.\n
        \t\t你希望客户端忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象.\n\n
        \t组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以像处理简单元素一样来处理复杂元素。
    </string>
    <string name="designpattern_Decorator_Activity_des">
        \t装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。\n\n
        \t装饰模式的角色：\n
        \t\t抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。\n
        \t\t具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。\n
        \t\t装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。\n
        \t\t具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。\n\n
        \t这种仅仅是对对象的行为进行扩展，从而可以不用通过继承的方式弄个子类出来。ConcreteDecorator的抽象接口调用了具体构建的接口行为外，就是对业务逻辑进行扩展的。\n
        \t主要：具体构件和装饰角色都实现了指定要扩展的抽象接口，具体的"装饰过程"在装饰对象实现抽象接口里面完成业务逻辑的扩展。
    </string>
    <string name="designpattern_Facade_Activity_des">
        \t外观模式的角色：\n
        \t\t门面角色（ facade ）：这是门面模式的核心。它被客户角色调用，因此它熟悉子系统的功能。它内部根据客户角色已有的需求预定了几种功能组合。\n
        \t\t子系统角色：实现了子系统的功能。对它而言， façade 角色就和客户角色一样是未知的，它没有任何 façade 角色的信息和链接。\n
        \t\t客户角色：调用 façade 角色来完成要得到的功能\n\n
        \t模式作用:
        \t\t将一些复杂的操作封装起来,以一个简单的接口提供给客户端;可以定义多个子系统, 层次之间的粗细粒度需要把握好.一个子系统一个门面类.\n\n
        \t类似中间层的概念，将上层：客户端和下层：子系统进行隔离，使得上层只能通过中间层来访问下层
    </string>
    <string name="designpattern_Flyweight_Activity_des">
        \t概念：也就是说在一个系统中如果有多个相同的对象，那么只共享一份就可以了，不必每个都去实例化一个对象。\n
        \t在Flyweight模式中，由于要产生各种各样的对象，所以在Flyweight(享元)模式中常出现Factory模式。Flyweight的内部状态是用来共享的,Flyweight factory负责维护一个对象存储池（Flyweight Pool）来存放内部状态的对象。Flyweight模式是一个提高程序效率和性能的模式,会大大加快程序的运行速度.应用场合很多.\n\n
        \t享元模式(分单纯享元和复合享元两种) - 单纯享元模式的角色:\n
        \t\t抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。\n
        \t\t具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。\n
        \t\t享元工厂(FlyweightFactory)角色 ：本角 色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有 一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个 合适的享元对象。\n\n\
        \t享元模式 - 复合享元模式的角色:\n
        \t\t复合享元(ConcreteCompositeFlyweight)角色 ：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。\n\n
        \t核心：在享元工厂里面有一个集合容器来储存各个对象，在创建对象的时候复用了内蕴状态。\n\n
        \t享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。享元对象能做到共享的关键是区分内蕴状态(Internal State)和外蕴状态(External State)。\n
        \t一个内蕴状态(Internal State)是存储在享元对象内部的，并且是不会随环境的改变而有所不同。因此，一个享元可以具有内蕴状态并可以共享。\n
        \t一个外蕴状态(External State)是随环境的改变而改变的、不可以共享的。享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。外蕴状态不可以影响享元对象的内蕴状态，它们是相互独立的。\n\n
        \t享元模式的优点和缺点:\n
        \t\t享元模式是一个非常简单的模式，它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能，但它同时也提高了系统复杂性，需要分离外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。\n\n
        \t适用场景：\n
        \t\t系统中存在大量的相似对象,细粒度的对象都具备较接近的外部状态，而且外部状态与环境无关，也就是说对象没有特定身份。\n
        \t\t需要缓冲池的场景。\n
    </string>
    <string name="designpattern_Proxy_Activity_des">
        \t代理模式的角色及其职责\n
        \t\tSubject：抽象主题角色，抽象主题类可以是抽象类，也可以是接口，是一个最普通的业务类型定义，无特殊要求。\n
        \t\tRealSubject：具体主题角色，也叫被委托角色、被代理角色。是业务逻辑的具体执行者。\n
        \t\tProxy：代理主题角色，也叫委托类、代理类。它把所有抽象主题类定义的方法给具体主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后工作。（最简单的比如打印日志）\n\n
        \t代理模式的应用形式\n
        \t\t(1)远程代理(Remote Proxy) -可以隐藏一个对象存在于不同地址空间的事实。也使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。\n
        \t\t(2)虚拟代理(Virtual Proxy) – 允许内存开销较大的对象在需要的时候创建。只有我们真正需要这个对象的时候才创建。\n
        \t\t(3)写入时复制代理(Copy-On-Write Proxy) – 用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。是虚拟代理的一个变体。\n
        \t\t(4)保护代理(Protection (Access)Proxy) – 为不同的客户提供不同级别的目标对象访问权限\n
        \t\t(5)缓存代理(Cache Proxy) – 为开销大的运算结果提供暂时存储，它允许多个客户共享结果，以减少计算或网络延迟。\n
        \t\t(6)防火墙代理(Firewall Proxy) – 控制网络资源的访问，保护主题免于恶意客户的侵害。\n
        \t\t(7)同步代理(SynchronizationProxy) – 在多线程的情况下为主题提供安全的访问。\n
        \t\t(8)智能引用代理(Smart ReferenceProxy) - 当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。\n
        \t\t(9)复杂隐藏代理(Complexity HidingProxy) – 用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时候也称为外观代理(Façade Proxy)，这不难理解。复杂隐藏代理和外观模式是不一样的，因为代理控制访问，而外观模式是不一样的，因为代理控制访问，而外观模式只提供另一组接口。\n\n
    </string>

    <string name="des_red_filter">R-红色:</string>
    <string name="des_green_filter">G-绿色:</string>
    <string name="des_blue_filter">B-蓝色:</string>
    <string name="des_alpha_filter">A-透明:</string>
</resources>